1.쓰레드와 프로세스의 차이를 이야기 해 보세요.

    내 답변 : 프로세스는 프로그램을 메모리에 로드시킨걸 말하고 쓰레드는 프로세르를 실행시키는 단위이다
    
    선생님 답변 : Process와 Thread의 가장 큰 차이는 사용하는 자원의 차이다.
                Process하나가 실행하기 위해서는 많은 메모리를 필요로 하지만, Thread는 상대적으로 적은 메모리를 필요로한다. 
                일반적인 프로그램은 Process하나에 하나 이상의 Thread가 수행된다. 
    
    
2.쓰레드 클래스를 만들기 위해서는 어떤 인터페이스를 구현하면 될까요?

    내 답변 : Runnable
    
    선생님 답변 : 쓰레드를 구현하기 위해서 java.lang.Runnable 인터페이스를 구현하면 된다.
    
    
3.위의 문제에서 이야기한 인터페이스에 선언되어 있는 유일한 메소드는 무엇인가요?

    내 답변 : run()
    
    선생님 답변 : Runnable 인터페이스에는 
                public void run() 
                메소드만이 선언되어 있다. 
    
    
4.쓰레드 클래스를 만들기 위해서 어떤 클래스를 확장하면 되나요?

    내 답변 : Thread
    
    선생님 답변 : 만약 별도로 확장하는 클래스가 없어 확장이 가능하다면,
                java.lang.Thread 클래스를 확장하여 사용해도 된다.
    
    
5.쓰레드가 시작되는 메소드의 이름은 무엇인가요?

    내 답변 : run()
    
    선생님 답변 : 쓰레드가 시작되는 메소드는 run() 메소드이다.    
    
    
6.쓰레드를 시작하는 메소드의 이름은 무엇인가요?

    내 답변 : start()
    
    선생님 답변 : 쓰레드를 시작하려면 run() 메소드가 아닌 start() 메소드를 호출해야만 한다.
    
    
7.쓰레드에 선언되어 있는 sleep() 메소드의 역할은 무엇인가요?

    내 답변 : 매개 변수로 넘어온 시간(1/1000초)만큼 대기한다.
    
    선생님 답변 : Thread의 sleep() 메소드는 매개변수로 넘겨준 시간만큼 해당 쓰레드를 멈춘다.
    
    
8.sleep() 메소드를 사용할 때 try-catch 로 감싸 주어야 하는 이유는 무엇인가요?

    내 답변 : sleep() 메소드로 대기하고 있는 중에 interrupt가 될 수 있으므로, InterruptedException 이 발생할 수 있다.
    
    선생님 답변 : sleep() 메소드로 대기하고 있는 중에 interrupt가 될 수 있으므로,
                InterruptedException 이 발생할 수 있다. 따라서, try-catch로 감싸주어야만 한다.
    
    
9.데몬(Daemon) 쓰레드와 일반 쓰레드의 차이는 무엇인가요?

    내 답변 : 데몬 쓰레드는 만약 프로세스가 종료되는 상황이 되었을때 해당 쓰레드가 종료되지 않아도
             다른 실행중인 일반 쓰레드가 없다면 해당 쓰레드는 중지된다.
    
    선생님 답변 : 데몬 쓰레드는 만약 프로세스가 종료되는 상황이 되었을때
                해당 쓰레드가 종료되지 않아도 다른 실행중인 일반 쓰레드가 없다면, 해당 프로세스는 중지된다. 
    
    
10.synchronized 구문은 왜 써 주며, 어디에 사용해야 하나요?

    내 답변 : 동시에 연산을 수행하는 경우 
    
    선생님 답변 : synchronized 구문은 동시에 여러 쓰레드에서 하나의 값에 접근하려고 할 때 데이터의 정합성(데이터 일치)을 지키기 위해서 사용한다.
                그러므로, 여러 쓰레드에서 동시에 접근할 일이 있을 경우에만 써야한다.
                그렇지 않으면 성능상 큰 문제가 발생할 수 있다.
    
    
11.synchronized 를 사용하는 두 가지 방법은 어떤 것 인가요?

    내 답변 : 메소드 자체 또는 특정문장만
    
    선생님 답변 : syhchronized는 메소드 자체를 synchronized로 선언하는 방법과
                메소드 내에 필요한 부분만 synchronized로 선언하는 두가지 방법이 있다.
    
    
12.쓰레드의 상태에는 어떤 것들이 있나요?

    내 답변 : NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
    
    선생님 답변 : 쓰레드의 상태는 NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED로 나뉜다.
    
    
13.쓰레드에 선언되어 있는 join() 메소드의 용도는 무엇인가요?

    내 답변 : 쓰레드가 끝날때까지 대기
    
    선생님 답변 : join()메소드는 해당 쓰레드가 종료될 때까지 대기한다.
    
    
14.쓰레드에 선언되어 있는 interrupt() 메소드의 용도는 무엇인가요?

    내 답변 : 실행중인 쓰레드를 중지
    
    선생님 답변 : interrupt() 메소드는 해당 쓰레드를 종료시킨다. 
    
    
15.interrupt() 메소드를 호출하면 해당 쓰레드는 어떤 상태에 있을 때 interrupt() 메소드가 호출된 효과가 발생 되나요?

    내 답변 : sleep(), join(), wait()
    
    선생님 답변 : sleep(), join(), wait() 메소드가 호출되어 대기중인 상태에만 interrupt() 메소드가 처리된다.
    
    
16.Object 클래스에 선언된 wait() 메소드의 용도는 무엇인가요?

    내 답변 : 다른 쓰레드가 Object객체에 대한 notify() 메소드나 notifyAll() 메소드를
             호출할 때까지 현재 쓰레드가 대기하고 있도록한다.
    
    선생님 답변 :  wait() 메소드는 다른 쓰레드가 Object 객체에 대한 notify() 메소드나
                notifyAll() 메소드를 호출할 때까지 현재 쓰레드가 대기하고 있도록 한다.
                만약 매개변수로 시간을 지정하면 wait() 메소드와 동일하지만, 해당 시간까지만 대기한다.
        
    
17.Object 클래스에 선언된 notify() 메소드의 용도는 무엇인가요?

    내 답변 : wait()로 대기하고 있는 단일 쓰레드를 깨운다
    
    선생님 답변 : notify() 메소드는 wait() 메소드로 대기중인 쓰레드가 계속해서 작업을 하도록 깨우는 작업을 한다.
    
    
18.ThreadGroup 클래스에 선언된 enumerate() 메소드의 용도는 무엇인가요?

    내 답변 : 배열로 담는 역할
    
    선생님 답변 : hreadGroup의 enumerate() 메소드는 해당 쓰레드 그룹에 포함된 쓰레드나
                쓰레드 그룹의 목록을 매개변수로 넘어온 배열에 담는다.