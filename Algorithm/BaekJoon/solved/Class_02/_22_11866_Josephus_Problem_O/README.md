# 알고리즘 풀이

Arraylist를 **for문을 통해 추가(add), 삭제(remove) 과정**을 했을 시 **삭제가 제대로 안될 수 있다.**  
이유로는 반복문이 순회를 하는 동안 **Collection가 변경되면서 ConcurrentModificationException 예외**가 발생된다.  
예시를 들어서 설명하겠다.

    배열 [1, 2, 3, 4, 5, 6, 7] 
    
    case 1. 추가(add) 과정

    1. 배열 [1, 2, 3, 4, 5, 6, 7,  ] 공간 추가
    2. 배열 [1, 2,  , 3, 4, 5, 6, 7] 데이터 이동 연산작업
    3. 배열 [1, 2, 8, 3, 4, 5, 6, 7] 데이터 삽입    
    
    case 2. 삭제(remove) 과정
    
    1. 배열 [1, 2, 3,  , 5, 6, 7] 선으로 데이터 삭제
    2. 배열 [1, 2, 3, 5, 6, 7,  ] 데이터 이동 연산작업
    3. 배열 [1, 2, 3, 5, 6, 7,  ] 빈 인덱스인 채로 마무리
    
위와 같은 과정을 갖추기에 공간을 추가, 삭제를 한다.    
그러므로 **공간자체를 변경하는 과정이 예외가 발생**한다.  
그래서 이를 해결하고자 다른 방식인 **Linkedlist**가 존재한다.

    Linkedlist [1] -> [2] -> [3] -> [4] -> [5] -> [6] -> [7] 
    
해당 값을 가르키는 것이 아닌 **해당값을 가지는 주소**를 가르킨다.

    case 1. 추가(add) 과정
    
    1. [1]  [node] [2] -> [3] -> [4] -> [5] -> [6] -> [7] 해당 위치에 노드 추가
    2. [1] -> [node] -> [2] -> [3] -> [4] -> [5] -> [6] -> [7]  
       node를 기준으로 1은 2가아닌 node를 가르키고 node는 2를 가르킨다.
       
    case 2. 삭제(remove) 과정   
    
    1. [1]  [node]  [2] -> [3] -> [4] -> [5] -> [6] -> [7] 삭제할 노드의 선을 끊는다.
    2. [1] -> [x] -> [2] -> [3] -> [4] -> [5] -> [6] -> [7]  
       node가 아닌 그다음 값을 가르킨다.
       
이런 과정으로 **Linkedlist는 삽입, 삭제 과정에서는 Arraylist보다 유리**하다.  
하지만 단점으로는 **읽는 방식이 단방향**이라서 **Arraylist 처럼 random access**가 안되서 검색이나 이런부분에서는 불리하다.  
또한 **데이터를 전체를 다룰때는 메모리랑 시간을 많이 잡아먹고 만들기가 어렵다.**
