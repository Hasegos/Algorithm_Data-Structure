Malloc & Pointer Review
-------------------------------------------------------------------------------------------------
int mian(void){
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
여기에서 y에 메모리를 할당을 해주지않으면 기존에 있던 쓰레기값등 문제로 저장이안된다.
만약 y = x 형태로 메모리를 복사하면 x 와 y는 같은 주소를 가르키기때문에 덮어씌워진다.
-------------------------------------------------------------------------------------------------


Resize Array
-------------------------------------------------------------------------------------------------
미리 정해야하는 하드코딩말고 동적 배열을 사용해야하는데 만약 배열 공간 3이 존재할때
값을 하나더 넣고싶으면 새로운 공간에 메모리할당해서 넣어주고 그전 배열은 해제시키면된다.
메모리를 미리 할당해주면 배열값을 넣을때 할당된 곳에 알아서 순서대로 넣어준다.
포인터 : 메모리 주소 , 배열 : 메모리 덩어리

relloc(메모리 재할당받은 애, 얼마나 받을지) :  relloc()를 통해 메모리를 재할당할 수 있다.
임시 변수에다가 relloc를 시켜줘야한다.
만약에 기존 변수에 새로 메모리 할당시키면 그전에 사용한 메모리는 어디로 갔는지 확인할 방도가없다.
즉, 기존에 연결 시킨 메모리들이 사라진다. 그리고 메모리가 줄줄 새는것을 막기위해서 해야한다.

빅오 표기법
Big-O : O(n)

O(n^2)
O(n log n)
O(n) : insert
O(log n) : search
O(1)
-------------------------------------------------------------------------------------------------


LinkedList : Introduction
-------------------------------------------------------------------------------------------------
struct : 구조체를 이용해서 우리만의 자료 종류를 만들 수 있다.
ex) 비트맵, 비트맵 헤더 등 
. : 속성값을 가지고올때 사용
Big-O : O(n)
문자열에서 NULL는 문자열이 끝났다는것을 알림, list에서 NULL는 포인터
node : 메모리 덩어리

node 구조체
typedef struct node{
    int number;
    struct node *next;    
}node;
-------------------------------------------------------------------------------------------------


LinkedList : Coding
-------------------------------------------------------------------------------------------------
  list   : node *list = NULL;
  list = n;
________ -> ________
|      |    |  2   |    node *n  = malloc(sizeof(node));
|______|    |______|    (*n).number = 2; == n -> number = 2;
            |      |    n -> next = NULL; 
            |______|    if(n != NULL){
                            n -> number = 2;
                            n -> next = NULL;
                        }

________ -> ________
|  2   |    |  4   |    node *n  = malloc(sizeof(node));
|______|    |______|    if(n != NULL){
|      |    |      |        n -> number = 4;
|______|    |______|        n -> next = NULL
                        }
                        node *tmp = list;
                        while(tmp -> next != NULL){
                            tmp = tmp -> next;            
                        }
만약 제일 앞에 1를 추가하고 싶을 떄
n -> next = list;
list = n;
-------------------------------------------------------------------------------------------------


LinkedList : Testing
-------------------------------------------------------------------------------------------------
연결리스트 통해 특정 위치에 추가, 삭제 등을 할수있지만 이로인해 임의 접근법을 잃어버렸다.
배열은 고정된 공간이라서 임의 접근법이 가능하지만 연결리스트는 순차적으로밖에 접근할 수 없다.
이로인해 이진 탐색이 불가능해졌다.
O(n^2)
O(n log n)
O(n) : search, insert(다 둘러보고 위치에 추가하면됨)
O(log n)
O(1)
-------------------------------------------------------------------------------------------------


LinkedList : Tree
-------------------------------------------------------------------------------------------------
연결리스트를 이진탐색을위해 2차원 개념으로 만듦
임의 접근이 불가능해서 2차원 트리개념으로 만듦
개념상 2차원을 만든것
        4
      ↙  ↘
    2        6
  ↙ ↘    ↙ ↘
 1     3  5     7

typedef struct node{
    int number;
    struct node *left;
    struct node *right;
}node;

bool search(node *tree){
    if(tree == NULL){
        return false;
    }
    else if(50 < tree -> number){
        return search(tree -> left);
    }
    else if(50 > tree -> number){
        return search(tree -> right);
    }
    else{
        return true;
    }
}

O(n^2)
O(n log n)
O(log n) : search , insert <- 이는 트리가 균형잡혀 있을 때만
O(n)
O(1)
-------------------------------------------------------------------------------------------------


HashTable
-------------------------------------------------------------------------------------------------
해시 테이블 : 배열과 연결 리스트를 조합해서 만든것
key 와 value 로 이루어진것
만약 같은 키에 여러개의 value를 넣고싶다면 연결리스트를 사용하거나 이진 탐색 트리 형태로 만든다.
해시 함수 : 인덱싱하는 데 사용되는 배열
Big-O : 최악의 경우의 수O(n), O(1)
O(n^2)
O(n log n)
O(n) : 운이 매우 나쁘면 search
O(log n)
O(1) : search
-------------------------------------------------------------------------------------------------


Try
-------------------------------------------------------------------------------------------------
트라이(try) : 어떤 자원을 절약하기 위해 다른 자원을 소비하는 패턴
트라이는 각각의 노드가 배열로 이루어진 트리이다.
각각의 노드를 배열로 잡아먹기때문에 메모리 사용량이 엄청크다.
빅오 표기법
Big-O : O(1)

ex) harry를 찾는다
                            ............h..............
                        ↙
        a...........................
                                    ↘
                                       ...............r.............
                                    ↙    
        ...............r.............
                                     ↘
                                        ...............y.............                

-------------------------------------------------------------------------------------------------


stack & Queue & Dictionary
------------------------------------------------------------------------------------------------- 
큐(Queue) : FIFO(First In First Out) 선입 선출 특징의 자료구조
enqueue - push: 줄에 들어가서 서는것
dequeue - pop : 줄을 빠져나오는 것

스택(stack) : LIFO(Last In First Out) 후입 선출 특징의 자료구조

딕셔너리(Dictionary) : 다양한 쌍으로 이루어진 자료구조(해시 테이블이랑 동일한 개념)
문자로도 참조가 가능
-------------------------------------------------------------------------------------------------

Quiz 6

1번 : int *tmp = relloc(list, 5 * sizeof(int));
2번 : 배열이 리스트보다 더 빠르다.
3번 : n -> number
4번 : O(n)
5번 : 루트 노트(root node)
6번 : 해시 함수
7번 : 10개
8번 : 큐(Queue)
9번 : *next
10번 : 메모리 주소 표기법