Pointer
----------------------------------------------------------------------------------
포인터는 컴퓨터의 메모리 주소
포인트 변수를 통해 해당 값이 있는 주소를 저장할수있다.
즉, 주소를 가르키면 거기에 있는 값이 나온다.
만약에 포인터를 안붙이고 변수를 가르키면 주소가 나오고
포인터를 붙여서 사용하면 주소에 해당하는 값이 나온다.

Pointer 사용법
%p : 주소를 출력하는 형식지정자
항상 16진수로 출력해줌 
& : ~ 의 주소 , 주소를 물어봐준다.
* : 그 주소로 가줘
즉, &는 그 주소를 물어봐주고 그 주소에 해당 값을 가져오고싶으면 *를 써야한다.


ex) int *p = 50;  변수  p ------> ox......... 주소를 가르킴
                  변수 *p -------> 50을 가르킴  
----------------------------------------------------------------------------------


Array vs Pointer
----------------------------------------------------------------------------------
포인터는 배열과 같다.
대신 배열은 자동으로 메모리 할당,해제를 해주지만 포인터는 수동으로 할당, 해제해줘야한다.
배열이라는 것을 컴파일러에서는 주소의 형태로 바꿔준다.
ex) a[1] -> *(a+1) 이런식으로 바꿔서 해석해줌

문자열을 서로다른 변수에 저장하면 다른 곳을 가르키기떄문에 관계연산자 "==" 사용할 수 없다.
즉,가르키는 주소가 다르기때문이다.
반면 기본타입같은경우는 같은 값을 가지는 곳을 주소로 가르키기때문에 관계연산자 "=="를 사용이가능하다.
----------------------------------------------------------------------------------


String 
----------------------------------------------------------------------------------
char *s == string 이처럼 사용하고싶으면 구조체를 통해 미리 정의해놓자. 
ex) typedef char* string; -> string == char *변수명 
여기서 문자열의  주소를 가르키면 첫 글자만 가르킨다.
그러나 프로그램안에서 반복문을 통해 \0(널)을 확인해서 문자열을 전체를 가르켜준다.
+ 첫글자의 주소를 기점으로 널나오기전까지의 문자 순서대로 1바이트씩 차이난다.    
----------------------------------------------------------------------------------


메모리 구조

힙 영역
----------------------------------------------------------------------------------
메모리(힙 영역)에서 malloc를 사용해서 동적으로 할당할 수 있다. 
다만 메모리를 할당했을시 사용을 다하면 메모리를 해제시켜줘야한다.
배열은 자동으로 해제가되지만 malloc를 사용해서 할당한 메모리는 자동 해제가 안된다.
메모리가 누수가 일어나는지 확인하는 명령어 : valgrind 파일 
위 명령어를 사용하면 메모리 누수를 확인할 수 있다.
----------------------------------------------------------------------------------


힙 영역 : malloc를 통해 할당 받는 곳
스택 영역 : 함수 호출시 지역변수, 매개변수 할당
| 코드 영역 |
|데이터 영역|
|  힙 영역  |
|    ↓     | 
|           | 
|           |
|           |
|           |
|    ↑     |
| 스택 영역 | 
|  noswap() |  a - > 2, b  - > 1, tmp -> 1
|   main()  | : 스택 프레임 x -> 1, y -> 2

교환 -> 스택 영역이라 호출이 끝나면 사라짐 그래서 교환이 안됨
해결법 -> 참조로 넘기면됨, 반환값으로 주던가
noswap(int a, int b){
    int tmp = a;
    a = b;
    b = tmp
} 

&로 각각의 주소를 받은뒤 주소끼리 변경
swap(int *a, int *b){
    int tmp = *a;
    *a = *b;
    *b = tmp
}
----------------------------------------------------------------------------------


swap의 실행 과정
----------------------------------------------------------------------------------
일반적인 "=" 으로 복사의 경우
서로다른 문자열의 주소를 한쪽에 복사할시 복사본을 바꾸면 원본도 바뀐다.
복사본의 주소는 원본의 주소이기때문에 원본의 주소를 바꾼다는 말과 같다. 

s  ->   E M M A \0
    ↗ 
  T  

복사 방법
strcpy(a,b) -> b 문자열을 a에 문자열 복사. 
여기서 중요한건 a에 메모리 할당을 해줘야함. 일반적으로 ""로 초기화 시키면 리터럴(읽기 전용)이되어버려서
복사가 불가능하다. 
리터럴 : 초기화를 시킨것(값을 넣는 행위)
----------------------------------------------------------------------------------


File Wirte
----------------------------------------------------------------------------------
파일 출력을 위한 FILE 이라는 타입이 있다.
fopen("파일 이름", "어떤식으로 오픈할건지")  <- 파일 입력할수있게끔해줌
어떤식으로 오픈할지 : "r", "w", "a", "r+", "w+", "a+" 6개가 존재함.
fprintf() : 파일용 printf()임 ,  파일에 출력할수있음
fclose() : 파일 닫기
파일을 만들떄 csv로 만들면 엑셀이나 이런 문서에 열어볼 수 있음
csv -> 쉽표로 구분해서 데이터를 넣음
----------------------------------------------------------------------------------


Read File
----------------------------------------------------------------------------------
fopen, malloc 같은 함수는 에러가 발생시 NULL값을 반환해줌
사진 파일도 2진법으로 되어있다.
배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일 순을 입력받는다.
fread(bytes, 3, 1, file)
여기서 배열은 unsinged가 되어야한다 범위가 0 ~ 255까지이기떄문
추가로 각 파일마다 약속된 입력 바이트가 존재한다.
----------------------------------------------------------------------------------


Quiz 5

1 번 : 20
2 번 : printf("%p\n",p);
3 번 : char *s = "CS50";
4 번 : printf("%c\n", *(s+2));
5 번 : 7바이트
6 번 : free()
7 번 : 힙(heap)
8 번 : fcreate()
9 번 : 10
10 번 : &x, &y